program           ::= { statement | macroDefine | macroCall }

macroCall	  ::= identifier "!" "(" expression { "," expression } ")"

macroDefine	  ::= "[syntax-meta]" identifier "(" macroParam { "," macroParam } ")" "{" { statement }  | macroParam "}"

macroParam	  ::= "#" identifier

statement         ::= assignStmt | controlFlowStmt | functionStmt | fileStmt | threadStmt | importStmt

importStmt        ::= "import" identifier { "::" identifier } [ "from" identifier ]

assignStmt        ::= "let" identifier "=" expression ";"
controlFlowStmt   ::= ifStmt | whileStmt | jumpStmt | returnStmt | matchStmt | unlessstmt | forStmt | elifStmt | doInStmt | varianetStmt

ifStmt            ::= "if" "(" condition ")" "do" block [ "else" block ] "end-if"
elifStmt	  ::= "elif" "(" condition ")" "do" block 
whileStmt         ::= "while" "(" condition ")" "do" block "end-while"
unlessStmt        ::= "unless" "(" condition ")" "do" block "end-unless"
forStmt		  ::= "for" expression "in" expression "do" block "end-for"
matchStmt	  ::= "match" expression "with" matchCase "end-match"
matchCase	  ::= "|" expression "=>" block ","
doInStmt	  ::= "do" "(" expression ")" "in" expression "end-do"
jumpStmt          ::= "jump" expression ";"
returnStmt        ::= "return" { expression } ";"
varianetStmt	  ::= "type" identifier "=" varianet { "|" variant }

functionStmt      ::= "func" identifier "(" [ parameters ] ")" block

variant           ::= identifier { "of" identifier }

parameters        ::= identifier { "," identifier }

fileStmt          ::= openFileStmt | closeFileStmt | readFileStmt | writeFileStmt | appendFileStmt

openFileStmt      ::= "open" "file" "for" ( "reading" | "writing" | "reading-and-writing" ) expression ";"
closeFileStmt     ::= "close" "file" expression ";"
readFileStmt      ::= "read" "file" "for" "reading" expression ";"
writeFileStmt     ::= "write" "file" expression "with" expression ";"
appendFileStmt    ::= "append" "file" expression "with" expression ";"

threadStmt        ::= "run" "thread" identifier [ "and" "join" ] ";"

block             ::= "{" { statement } "}"

expression        ::= logicalOrExpr | "_"

logicalOrExpr     ::= logicalAndExpr { "or?" logicalAndExpr }
logicalAndExpr    ::= equalityExpr { "and?" equalityExpr }
equalityExpr      ::= relationalExpr { ( "==" | "!=" ) relationalExpr }
relationalExpr    ::= additiveExpr { ( "<" | "<=" | ">" | ">=" ) additiveExpr }
additiveExpr      ::= multiplicativeExpr { ( "+" | "-" ) multiplicativeExpr }
multiplicativeExpr ::= unaryExpr { ( "*" | "/" | "%" ) unaryExpr }

lambdaExpr        ::= "(" parameters ")" "=>" block { "(" ")" }

ternaryExpr 	  ::= condition "?" expression ":" expression

unaryExpr         ::= [ ( "+" | "-" | "!" | "$" ) ] primaryExpr

primaryExpr       ::= identifier
                  | number
                  | string
                  | "(" expression ")"
                  | functionCall
                  | array
                  | hashmap
                  | regexMatch
                  | execCommand
		  | ternaryExpr
		  | lambdaExpr
		  | argumentBackRef

argumentBackRef   ::= "#[" integer "]"

functionCall      ::= identifier "(" [ arguments ] ")"
arguments         ::= expression { "," expression }

array            ::= "[" [ arrayElements ] "]"
arrayElements    ::= expression { "," expression }

hashmap          ::= "{" [ keyValues ] "}"
keyValues        ::= expression ":" expression { "," expression ":" expression }

regexMatch       ::= expression "~" expression

regexNoMatch      ::= expression "!~" expression

execCommand      ::= "exec-pipe" expression ";"


condition        ::= expression

identifier       ::= letter { letter | digit | "_" }

number           ::= integer | floatingPoint
integer          ::= digit { digit }
hexNum		 ::= ( "0x" | "0X" ) { hexDigit }
octNum		 ::= ( "0o" | "oO" ) { octDigit }
binNum		 ::= ( "0b" | "0B" ) { "0" | "1" }
floatingPoint    ::= digit { digit } "." digit { digit }


multiLnQuotedString ::= quoteOpeners { character } quoteClosers

quoteClosers	 ::= "/" | ">" | ")" | "}" | "%" | "]"
quoteOpeners	 ::= "q/" | "q<" | "q(" | "q{" | "q%" | "q["

multiLnString 	 ::= "`" { character | "${" expression "}" } "`"

quotedString	 ::= "'"  { character } "'"
string           ::= "\"" { character | "${" expression "}" } "\""
character 	 ::= { letter } | cEscapes

letter           ::= "a" | "b" | ... | "z" | "A" | "B" | ... | "Z"
digit            ::= "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
hexDigit	 ::= "0" | "1" | ... | "9" | "A" | "B" | ... | "F" | "a" | ... | "f"
octDigit	 ::= "0" | "1" | ... | "7"

cEscapes 	 ::= "'" | "\"" | "?" | "\\" | "a" | "b" | "f" | "n" | "r" | "t" | "v" | "0" | hexEscape | octEscape
hexEscape 	 ::= "\\x" { hexDigit }
octEscape        ::= "\" { octDigit }




