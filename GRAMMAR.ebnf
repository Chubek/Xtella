program            = statement_list ;

statement_list     = { statement } ;

statement          = assign_stmt
                   | control_flow_stmt
                   | function_stmt
                   | rw_stmt
                   | exec_stmt
                   | open_stmt
                   | close_stmt ;

assign_stmt        = (non_indexed_ident | indexed_ident) ":=" expression ;

control_flow_stmt  = if_stmt
                   | while_stmt
                   | for_stmt
                   | return_stmt
                   | match_stmt
                   | unless_stmt ;

exec_stmt          = "[[x]]" "<<" ? any-unicode-char-including-newline ? ">>" ;

rw_stmt            = "read" ( "[[" name "]]" ) "into" name
                   | "read" string_const "into" name
                   | "write" expression ( "[[" name "]]" ) ( "[[" name "]]" )
                   | "append" expression "into" ( "[[" name "]]" ) 
		  ;

close_stmt         = "close" ( "[[" name "]]" ) ;

open_stmt          = "open" string_const "for" rw_mode
                   | "open" string_const "for" rw_mode "as" ( "[[" name "]]" ) 
		  ;

rw_mode            = "[[r]]"
                   | "[[w]]"
                   | "[[a]]"
                   | "[[rw]]" 
		  ;

if_stmt            = "if" "(" condition ")" "do" block "else" block "end" ;

while_stmt         = "while" "(" condition ")" "do" block "end" ;

for_stmt           = "for" expression "in" expression "do" block "end" ;

return_stmt        = "return" expression ";" ;

match_stmt         = "match" expression "with" match_case_list "end" ;

match_case_list    = match_case { "," match_case } ;

match_case         = "|" expression "=>" block "," ;

unless_stmt        = "unless" "(" condition ")" "do" block "end" ;

function_stmt      = "defun" name "(" identifier_list ")" block ;

identifier_list    = [ name { "," name } ] ;

block              = "{" statement_list "}" ;

expression         = compound_expr | "_" | regex_match | regex_nonmatch | ternary_expr ;

compound_expr      = unary_expr { binary_op unary_expr } ;

binary_op          = "||" | "&&" | "|" | "^" | "&" | "=" | "!=" | "<" | "<=" | ">" | ">=" | "-" | "+"
                  | "*" | "/" | "%" | "**" | "<|" | "|>" ;

unary_expr         = primary_expr | "+" unary_expr | "-" unary_expr | "!" unary_expr | "~" unary_expr
                  | "$" unary_expr 
		 ;

primary_expr       = const_value | function_call | lambda_expr | indexed_ident | non_indexed_ident ;

indexed_ident      = ( name "[" ) const_value "]" ;

non_indexed_ident  = ( "&" name ) | ( "%" name ) | ( "@" name )
                  | ( "$" name ) | ( "^" name ) ;

function_call      = name "(" argument_list ")" ;

ternary_expr       = expression "?" expression ":" expression ;

lambda_expr        = "[" argument_list "]" "=>" block ";" ;

argument_list      = expression { "," expression } ;

regex_match        = expression "=~" regex_const ;

regex_nonmatch     = expression "!=~" regex_const ;

const_value        = array | hashmap | number | string_const ;

array              = "{" [ expression { "," expression } ] "}" ;

hashmap            = "{" key_values "}" ;

key_values         = expression ":" expression { "," expression ":" expression } ;

condition          = expression ;

number             = integer | float ;

float              = ? any-digit-repeated ? { ( "." | "E" | "e" ) [ "-" | "+" ] ? any-digit-repeated ? } ;

integer            = ? any-digit-repeated ?  
                  | ( "0b" | "0B" ) ? zero-or-one-repeated ? 
		 | ( "0x" | "0X" ) ? hexadecimal-digits-repeated ? 
		 | ( "0o" | "0O" ) ? zero-to-seven-repeated ? 
		 ;

string_const       = mln_qstring 
                  | mln_fstring 
		 | qstring 
		 | fstring 
		 ;

regex_const        = regex_opener ? any-unicode-char-except-newline ? regex_closer ;

regex_closer       = "/" | ">" | "}" | ")" | "%" | "}" ;

regex_opener       = "m/" | "m<" | "m{" | "m(" | "m%" | "m[" ;

mln_fstring        = '"""' mln_fstring_body '"""' ;

mln_fstring_body   = ? any-unicode-char-including-newline ? | "${" expression "}" ;

mln_qsring        = quote_openers ? any-unicode-char-including-newline ? quote_closers ;

quote_closers      = "/" | "<" | ")" | "}" | "%" | "]" ;

quote_openers      = "q/" | "q<" | "q(" | "q{" | "q%" | "q[" ;

fstring            = '"' fstring_body '"' ;

fstring_body       = ? any-unicode-char-except-newline ? | "${" expression "}" ;

qstring            = "'" ? any-unicode-char-except-newline ? "'" ;

name              = ? c-style-identifier ? ;
t
